git branch -a
git checkout main
git reset --hard FETCH_HEAD
git fetch origin
git pull
git add .
git status
git commit -m "message"
git push



========================
ssh-keygen
ssh-keygen -t rsa -b 4096 -C "your_email@example.com"

ls -pal ~/.ssh
clip <~/.ssh/id_rsa.pub


=======================================================================

https://docs.conda.io/en/latest/miniconda.html
https://code.visualstudio.com/docs/?dv=win
https://git-scm.com/download/win



https://discuss.codecademy.com/t/setting-up-conda-in-git-bash/534473

======================================== Git init push, V1, V2 ======================================

1. Initialize Git inside your project
cd your_project/
git init
git add .
git commit -m "MVP Version 1 stable"

2. Create a GitHub repo and push
git remote add origin <repo-url>
git branch -M main
git push -u origin main

============================================== Create a test branch =============================================
Now your v1 is safely stored.

ðŸ”¥ Create a Branch for Version 2 Work

So Version-1 stays intact, Version-2 can evolve safely.

git checkout -b version2-dev

=========================================Merging V2 to main ===============================================================
Step 1: Make sure Version-2 branch is clean

You should currently be on version2-dev.

git status


If you see changes, commit them:

git add .
git commit -m "Version 2: stable working implementation"

Step 2: Merge Version-2 into main (promote V2 â†’ stable)

Switch to main:

git checkout main


Merge V2:

git merge version2-dev


Now:

main = Version-2 (stable)

Version-1 is preserved in Git history forever

Step 3: Tag this stable version (VERY important)

Tags let you checkpoint experiments cleanly.

git tag v2.0


(Optional but recommended)

git tag -a v2.0 -m "Stable Version 2"


You can always return to it with:

git checkout v2.0

Step 4: Create Version-3 branch for new experiments

Now branch from the new stable main:

git checkout -b version3-dev


Your state is now:

main        â†’ Version 2 (stable)
version2-dev â†’ archived / optional
version3-dev â†’ active experiments

Step 5: Safe iteration rule (golden rule)

While working on V3:

Commit often

git commit -am "V3: experiment with routing strategy"


If V3 fails badly:

git checkout main


If V3 succeeds:

git checkout main
git merge version3-dev
git tag v3.0

================================================== If V2 fails ====================================================================


Modify, rewrite, experiment freely.

If V2 breaks badly â†’ just switch back anytime:

git checkout main   # returns to Version 1
=============================================Create Git ignore==============================================================

touch .gitignore
echo "__pycache__/
*.pyc
venv/
.env/
data/
datasets/
*.pth
*.pt
*.ckpt
*.bin
*.whl
*.safetensors
logs/
output/
.vscode/
ipynb_checkpoints/" > .gitignore

=================================== make git subfolder flat =======================================

rm -rf submodule1/.git
rm -rf submodule2/.git
git add .
git commit -m "Integrated components, removed internal git repos"


==========================================================================================================
------------------ Dettach VS code from Server GPU

âœ… Best Practice (Recommended): tmux
This is the gold standard for remote ML training.
Start a persistent session

tmux new -s train

Run your training inside tmux:

CUDA_VISIBLE_DEVICES=0,1 torchrun train.py ...

Detach safely (job keeps running)
Press:
Ctrl + b, then d

You can now:
â€¢	Close VS Code
â€¢	Lose internet
â€¢	Shut your laptop
Training will continue.

Reattach later

tmux attach -t train

Useful tmux commands

tmux ls                 # list sessions
tmux kill-session -t train

________________________________________
âœ… Alternative: screen
Older but works.
screen -S train
# run training
Ctrl + a, then d        # detach
screen -r train         # reattach





==========================================================================================================


from cgi import print_environ_usage


print ("hello world")
f = open ("test.txt");
print(f)
lines  = f.readlines()
print(lines);


the_sum = 0
for line in lines:
    the_sum = the_sum + int(line)
    print(the_sum)  

print("---------------------")
# comment ---- this is a test
print(sum (int (x) for x in lines))
# 
